Great question ‚Äî this is classic offline-first / hybrid sync architecture, and there is a better approach than a ‚Äúnormal CRUD API flow‚Äù.

For a POS offline app with SQLite + online sync, you should NOT treat it like a regular online-only app.

Below is the industry-proven architecture used by POS, banking, logistics, and field apps.

‚ùå What NOT to do (common mistake)

‚ÄúWhen user saves ‚Üí call API ‚Üí if offline, fail‚Äù

Problems:

Data loss

Broken UX

Sync conflicts

Impossible reconciliation

‚úÖ Correct approach: Offline-First + Sync Engine
Core Principle

SQLite is the source of truth
Server is a replica, not the primary DB

High-level Architecture
UI
 ‚Üì
Local SQLite (always write)
 ‚Üì
Sync Queue / Change Log
 ‚Üì
Sync Engine
 ‚Üì
Remote API

1Ô∏è‚É£ Always save locally first (non-negotiable)

Every operation:

Sale

Payment

Refund

Inventory update

üëâ Write to SQLite immediately, even when online.

Example:

Sale completed ‚Üí saved locally ‚Üí receipt printed ‚Üí DONE


POS must never depend on network to complete a sale.

2Ô∏è‚É£ Use a Sync Queue (very important)

Create a table like:

sync_queue (
  id UUID,
  entity_type TEXT,      -- sale, payment, product
  entity_id UUID,
  operation TEXT,        -- CREATE, UPDATE, DELETE
  payload JSON,
  status TEXT,           -- PENDING, SYNCED, FAILED
  retry_count INT,
  created_at TIMESTAMP
)


Every local change:

Save data to main table

Add record to sync_queue

This gives you:

Retry

Ordering

Audit trail

Conflict handling

3Ô∏è‚É£ Background Sync Engine

Runs when:

Internet is available

App starts

Periodically (every X minutes)

Flow:

FOR each PENDING record in sync_queue:
  ‚Üí send to server
  ‚Üí if success ‚Üí mark SYNCED
  ‚Üí if fail ‚Üí retry later


üö® Important:

Sync must be idempotent

Server must handle duplicate requests safely

4Ô∏è‚É£ Server-side: accept offline reality

Your API must:

Accept client-generated UUIDs

Accept timestamps from client

Allow delayed writes

Handle duplicates

Example
{
  "sale_id": "uuid-from-client",
  "created_at": "2026-02-18T10:21:00",
  "device_id": "POS-DEVICE-01"
}


Server checks:

If already exists ‚Üí ignore / update

If new ‚Üí insert

5Ô∏è‚É£ Conflict strategy (keep it simple)

POS systems usually avoid complex conflicts by design.

Common strategies:

Last write wins (most POS)

Server authoritative for inventory

Client authoritative for sales

Example:

Sales ‚Üí client always wins

Product prices ‚Üí server wins

Inventory ‚Üí server recalculates

üëâ Avoid multi-device editing of same records when possible.

6Ô∏è‚É£ Pull sync (don‚Äôt forget this)

Hybrid means:

Push local changes

Pull server changes

Add:

sync_metadata (
  last_sync_at TIMESTAMP
)


Flow:

GET /sync?since=last_sync_at
‚Üí update local SQLite
‚Üí update last_sync_at


Used for:

Price changes

New products

Tax rules

Promotions

7Ô∏è‚É£ Data versioning (small but powerful)

Add:

updated_at

version (optional integer)

This helps:

Conflict detection

Debugging

Partial sync

8Ô∏è‚É£ Recommended architecture summary
‚úî Best practice for POS
Layer	Responsibility
UI	Never talk to API directly
Local DB	Always writable
Sync Queue	Track all changes
Sync Engine	Push + pull
API	Idempotent + tolerant
9Ô∏è‚É£ When is ‚Äúnormal API flow‚Äù acceptable?

Only if:

Read-only app

No payments

No legal/financial records

‚ùå Never acceptable for POS

10Ô∏è‚É£ Bonus: future-proofing

If you later add:

Multiple devices

Cloud dashboard

Offline reports

This architecture already supports it.

Final recommendation (short)

Offline-first + local SQLite + sync queue + background sync engine
Not direct API writes.